<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Worträtsel-Solver (Pinch‑to‑Select)</title>
<style>
  :root{--bg:#0b1220;--fg:#e5e7eb;--muted:#9aa4b2;--acc:#22d3ee;--ok:#a7f3d0;--warn:#fbbf24;--mono:ui-monospace,Menlo,Consolas,monospace;}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);}
  header{padding:12px 14px 0;}
  h1{margin:0 0 6px;font-size:1.2rem}
  p.hint{margin:4px 0 0;color:var(--muted);font-size:.9rem}
  .wrap{display:grid;gap:10px;padding:12px 14px}
  @media(min-width:980px){.wrap{grid-template-columns: 480px 1fr;}}
  .card{border:1px solid #1f2a44;border-radius:10px;background:#0a1324;padding:12px}
  .card h2{font-size:1rem;margin:0 0 8px;color:var(--acc)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{appearance:none;border:0;border-radius:999px;padding:10px 14px;font-weight:700;cursor:pointer;background:radial-gradient(100% 100% at 0 0,#0ea5e9 0,#22d3ee 100%);color:#001018}
  button.secondary{background:#1f2937;color:var(--fg)}
  input[type="number"],input[type="text"]{width:90px;padding:8px 10px;border-radius:10px;border:1px solid #24314a;background:#0b1220;color:var(--fg)}
  input[type="file"]{color:var(--fg)}
  #status{color:var(--muted);font-size:.9rem;margin-top:8px}
  #status.ok{color:var(--ok)} #status.warn{color:var(--warn)}
  #stage{position:relative; border-radius:8px;border:1px solid #1f2a44;background:#000; overflow:hidden; touch-action:none; -ms-touch-action:none;}
  canvas{display:block;max-width:100%;height:auto}
  .overlayTip{font-size:.85rem;color:var(--muted)}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #2a3a57;background:#0b1a33;color:#a5b4fc;font-size:.75rem}
  pre{white-space:pre-wrap;word-break:break-word;font-family:var(--mono)}
  .grid{display:inline-grid;gap:4px;border:1px dashed #264; padding:6px;border-radius:8px}
  .cell{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border:1px solid #244;background:#0b1220;border-radius:4px;font-family:var(--mono)}
</style>
</head>
<body>
<header>
  <h1>Worträtsel-Solver</h1>
  <p class="hint">Pinch‑to‑Select: Lege zwei Finger auf die gewünschten <em>gegenüberliegenden Ecken</em> des Bereichs (Gitter oder Wortliste). Seiten‑Zoom ist deaktiviert.</p>
</header>

<div class="wrap">
  <section class="card">
    <h2>1) Bildquelle</h2>
    <div class="row">
      <input id="file" type="file" accept="image/*" capture="environment">
      <button id="openCam" class="secondary" type="button">Kamera</button>
      <button id="snap" class="secondary" type="button" disabled>Foto aufnehmen</button>
    </div>
    <video id="video" playsinline style="width:100%;display:none;border-radius:8px;border:1px solid #1f2a44"></video>
    <div id="stage">
      <canvas id="canvas" width="1280" height="960"></canvas>
    </div>
    <div class="overlayTip">
      1 Finger: feine Rechtecke ziehen (optional).<br/>
      2 Finger: <strong>Pinch‑to‑Select</strong> – das Rechteck wird durch die beiden Fingerpositionen definiert.
    </div>
    <div class="row" style="margin-top:8px">
      <button id="markGrid" type="button">Modus: Gitter</button>
      <button id="markWords" class="secondary" type="button">Modus: Wortliste</button>
      <button id="clearRects" class="secondary" type="button">Markierungen löschen</button>
    </div>
    <div class="row" style="margin-top:8px">
      <label>Zeilen R <input id="rows" type="number" min="5" max="50" value="13"></label>
      <label>Spalten C <input id="cols" type="number" min="5" max="50" value="13"></label>
    </div>
    <div id="status">Bereit.</div>
  </section>

  <section class="card">
    <h2>2) OCR & Lösung</h2>
    <div class="row">
      <button id="run" type="button">OCR starten & lösen</button>
      <span class="pill" id="progressPill">0%</span>
    </div>
    <div class="row" style="margin-top:8px">
      <label>Lösungswort (optional) <input id="solution" type="text" placeholder="optional"></label>
    </div>
    <div style="margin-top:10px">
      <div><strong>Gefundene Wörter:</strong></div>
      <pre id="wordsOut"></pre>
    </div>
    <div>
      <div><strong>Gitter (OCR → normalisiert):</strong></div>
      <div id="gridOut"></div>
    </div>
    <div style="margin-top:10px">
      <div><strong>Rest / Lösungswort:</strong> <span id="leftover" style="font-family:var(--mono)"></span></div>
    </div>
  </section>
</div>

<script src="https://unpkg.com/tesseract.js@v5.0.4/dist/tesseract.min.js"></script>
<script>
// Disable browser zoom via keyboard/touchpad (defensive)
document.addEventListener('wheel', e => { if(e.ctrlKey){ e.preventDefault(); } }, {passive:false});
document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('gesturechange', e => e.preventDefault());
document.addEventListener('gestureend', e => e.preventDefault());

const fileInput=document.getElementById('file');
const openCamBtn=document.getElementById('openCam');
const snapBtn=document.getElementById('snap');
const video=document.getElementById('video');
const stage=document.getElementById('stage');
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');

let stream=null;
let imgBitmap=null;

// ---------- CAMERA ----------
openCamBtn.onclick = async()=>{
  try{
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
    video.srcObject = stream; await video.play();
    video.style.display='block'; snapBtn.disabled=false;
    setStatus('Kamera aktiv.');
  }catch(e){
    setStatus('Kamera konnte nicht geöffnet werden: '+e.message);
  }
};
snapBtn.onclick = async()=>{
  if(!video.videoWidth){return;}
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  try{ video.pause(); if(stream){ for(const t of stream.getTracks()) t.stop(); } }catch{}
  stream=null; video.srcObject=null; video.style.display='none';
  imgBitmap = await createImageBitmap(canvas.transferToImageBitmap ? canvas.transferToImageBitmap() : canvas);
  setStatus('Foto übernommen. Kamera deaktiviert.');
  snapBtn.disabled=true;
};

fileInput.onchange = async(ev)=>{
  const f=ev.target.files?.[0]; if(!f) return;
  const img = new Image(); img.onload=async()=>{
    const maxW=2000; const scale=Math.min(1, maxW/img.width);
    canvas.width = Math.round(img.width*scale); canvas.height = Math.round(img.height*scale);
    ctx.drawImage(img,0,0,canvas.width,canvas.height);
    imgBitmap = await createImageBitmap(img);
    setStatus('Bild geladen.');
    redraw();
  };
  img.src = URL.createObjectURL(f);
};

function setStatus(s){ const el=document.getElementById('status'); el.textContent=s; el.className=''; }

// ---------- DRAW helpers ----------
let rects={grid:null, words:null};
let mode='grid';
document.getElementById('markGrid').onclick=()=>{ mode='grid'; setStatus('Modus: Gitter. Pinch‑to‑Select ausführen.'); };
document.getElementById('markWords').onclick=()=>{ mode='words'; setStatus('Modus: Wortliste. Pinch‑to‑Select ausführen.'); };
document.getElementById('clearRects').onclick=()=>{ rects={grid:null,words:null}; redraw(); };

function drawRect(r,color){
  if(!r) return;
  const rN = normalizeRect(r);
  ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.setLineDash([8,6]);
  ctx.strokeRect(rN.x, rN.y, rN.w, rN.h); ctx.restore();
}
function redraw(){
  if(!imgBitmap){ return; }
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(imgBitmap, 0, 0, canvas.width, canvas.height);
  drawRect(rects.grid,'#22d3ee'); drawRect(rects.words,'#a7f3d0');
}
function normalizeRect(r){
  return {x:Math.min(r.x,r.x+r.w), y:Math.min(r.y,r.y+r.h), w:Math.abs(r.w), h:Math.abs(r.h)};
}
function clientToCanvas(x,y){
  const b = canvas.getBoundingClientRect();
  const sx = canvas.width / b.width;
  const sy = canvas.height / b.height;
  return { x: (x - b.left) * sx, y: (y - b.top) * sy };
}

// ---------- PINCH‑TO‑SELECT ----------
const touches=new Map();
let singleDrag=null; // optional single‑finger fine adjust

stage.addEventListener('pointerdown', (e)=>{
  stage.setPointerCapture(e.pointerId);
  touches.set(e.pointerId, {x:e.clientX, y:e.clientY});
  if(touches.size===1){
    // allow single‑finger rectangle (optional)
    const p = clientToCanvas(e.clientX, e.clientY);
    singleDrag = {start:p, key:mode};
    rects[mode] = {x:p.x, y:p.y, w:0, h:0};
    redraw();
  }
  e.preventDefault();
},{passive:false});

stage.addEventListener('pointermove', (e)=>{
  if(!touches.has(e.pointerId)) return;
  touches.set(e.pointerId,{x:e.clientX,y:e.clientY});
  if(touches.size===2){
    // pinch defines rectangle corners (two touch points)
    const pts=[...touches.values()];
    const a=clientToCanvas(pts[0].x, pts[0].y);
    const b=clientToCanvas(pts[1].x, pts[1].y);
    rects[mode] = {x:a.x, y:a.y, w:b.x-a.x, h:b.y-a.y};
    redraw();
  }else if(touches.size===1 && singleDrag){
    const p = clientToCanvas(e.clientX, e.clientY);
    rects[singleDrag.key].w = p.x - singleDrag.start.x;
    rects[singleDrag.key].h = p.y - singleDrag.start.y;
    redraw();
  }
  e.preventDefault();
},{passive:false});

function endPointer(e){
  touches.delete(e.pointerId);
  singleDrag=null;
}
stage.addEventListener('pointerup', endPointer, {passive:false});
stage.addEventListener('pointercancel', endPointer, {passive:false});

// ---------- OCR / SOLVER ----------
const progressPill=document.getElementById('progressPill');
function norm(s){
  if(!s) return "";
  s = s.replace(/ä/gi,'ae').replace(/ö/gi,'oe').replace(/ü/gi,'ue').replace(/ß/g,'ss');
  s = s.replace(/[^A-Za-z]/g,'');
  return s.toUpperCase();
}
const DIRS=[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];

async function ocrRegion(rImg){
  if(!rImg) throw new Error('Kein Rechteck gesetzt');
  const r = normalizeRect(rImg);
  const off=document.createElement('canvas'); off.width=r.w; off.height=r.h;
  const octx=off.getContext('2d');
  octx.drawImage(imgBitmap || canvas, r.x, r.y, r.w, r.h, 0, 0, r.w, r.h);
  const id=octx.getImageData(0,0,r.w,r.h);
  const d=id.data;
  for(let i=0;i<d.length;i+=4){
    const g=(d[i]*0.299+d[i+1]*0.587+d[i+2]*0.114);
    const v=g>180?255:(g<70?0:g);
    d[i]=d[i+1]=d[i+2]=v;
  }
  octx.putImageData(id,0,0);
  const worker = await Tesseract.createWorker('deu', 1, {
    logger: m => { if(m.status==='recognizing text' && m.progress!=null){ progressPill.textContent = Math.round(m.progress*100)+'%'; } },
    langPath: 'https://tessdata.projectnaptha.com/4.0.0'
  });
  const res = await worker.recognize(off);
  await worker.terminate();
  return res;
}

function cluster1D(items, count, coordFn){
  const pts = items.map(coordFn).sort((a,b)=>a-b);
  const n = Math.min(count, pts.length); if(n===0) return [];
  let centers=[];
  for(let i=0;i<n;i++){ centers.push(pts[Math.floor((i+0.5)*pts.length/n)]); }
  for(let iter=0;iter<20;iter++){
    const buckets=Array.from({length:n},()=>[]);
    for(const p of pts){
      let bi=0,bd=Infinity;
      for(let i=0;i<n;i++){const d=Math.abs(p-centers[i]); if(d<bd){bd=d;bi=i;}}
      buckets[bi].push(p);
    }
    let shift=0;
    for(let i=0;i<n;i++){
      if(buckets[i].length){ const m=buckets[i].reduce((a,b)=>a+b,0)/buckets[i].length; shift+=Math.abs(m-centers[i]); centers[i]=m; }
    }
    if(shift<0.1) break;
  }
  centers.sort((a,b)=>a-b);
  return centers;
}
function buildGridFromWords(items, R, C){
  const letters = items.filter(it => /^[A-ZÄÖÜß]$/.test(it.text));
  if(letters.length < R*C*0.6) { return null; }
  const rowCenters = cluster1D(letters, R, it=> (it.bbox.y0+it.bbox.y1)/2 );
  const colCenters = cluster1D(letters, C, it=> (it.bbox.x0+it.bbox.x1)/2 );
  const grid = Array.from({length:R},()=>Array(C).fill(''));
  for(const it of letters){
    const yc=(it.bbox.y0+it.bbox.y1)/2, xc=(it.bbox.x0+it.bbox.x1)/2;
    let ri=0,rd=Infinity; for(let i=0;i<rowCenters.length;i++){const d=Math.abs(yc-rowCenters[i]); if(d<rd){rd=d;ri=i;}}
    let ci=0,cd=Infinity; for(let j=0;j<colCenters.length;j++){const d=Math.abs(xc-colCenters[j]); if(d<cd){cd=d;ci=j;}}
    const ch = norm(it.text);
    if(ch) grid[ri][ci]=ch[0];
  }
  for(let i=0;i<R;i++)for(let j=0;j<C;j++){ if(!grid[i][j]) grid[i][j]='?'; }
  return grid.map(r=>r.join(''));
}
function parseWordlist(text){
  return Array.from(new Set(text.split(/[\r\n]+/).map(s=>norm(s)).filter(Boolean)));
}
function findWordsInGrid(gridLines, words){
  const R=gridLines.length, C=gridLines[0].length;
  const grid = gridLines.map(r=>r.split(''));
  function inb(r,c){return r>=0&&r<R&&c>=0&&c<C}
  function exists(w){
    const L=w.length;
    for(let r=0;r<R;r++)for(let c=0;c<C;c++){
      for(const [dr,dc] of [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]){
        let rr=r, cc=c, ok=true;
        for(let k=0;k<L;k++){ if(!inb(rr,cc)||grid[rr][cc]!==w[k]){ok=false;break;} rr+=dr; cc+=dc; }
        if(ok) return true;
      }
    }
    return false;
  }
  const found=[]; for(const w of words){ if(w && exists(w)) found.push(w); }
  return found;
}
function solver_leftover(gridLines, placedWords){
  const R=gridLines.length, C=gridLines[0].length;
  const grid = gridLines.map(r=>r.split(''));
  const mark = Array.from({length:R},()=>Array(C).fill(false));
  function inb(r,c){return r>=0&&r<R&&c>=0&&c<C}
  function markWord(w){
    const L=w.length;
    for(let r=0;r<R;r++)for(let c=0;c<C;c++){
      for(const [dr,dc] of [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]){
        let rr=r, cc=c, ok=true;
        for(let k=0;k<L;k++){ if(!inb(rr,cc)||grid[rr][cc]!==w[k]){ok=false;break;} rr+=dr; cc+=dc; }
        if(ok){ rr=r; cc=c; for(let k=0;k<L;k++){ mark[rr][cc]=true; rr+=dr; cc+=dc; } }
      }
    }
  }
  for(const w of placedWords) markWord(w);
  let out=""; for(let r=0;r<R;r++)for(let c=0;c<C;c++) if(!mark[r][c]) out+=grid[r][c];
  return out;
}

document.getElementById('run').onclick = async()=>{
  const R=+document.getElementById('rows').value;
  const C=+document.getElementById('cols').value;
  if(!rects.grid || !rects.words){ setStatus('Bitte beide Rechtecke markieren (Gitter + Wortliste) – per Pinch.'); return; }
  setStatus('OCR läuft … (Gitter)');
  const gridRes=await ocrRegion(rects.grid);
  setStatus('OCR läuft … (Wortliste)');
  const wordsRes=await ocrRegion(rects.words);

  const letterItems = gridRes.data.words.flatMap(w=> w.symbols.map(s=>({
    text: s.text,
    bbox: s.bbox || {x0:w.bbox.x0,y0:w.bbox.y0,x1:w.bbox.x1,y1:w.bbox.y1}
  })));
  let grid = buildGridFromWords(letterItems, R, C);
  if(!grid){ const st=document.getElementById('status'); st.className='warn'; st.textContent='Zu wenige Buchstaben erkannt. Versuche die Rechtecke enger zu setzen.'; return; }

  const rawText = wordsRes.data.text || '';
  const words = parseWordlist(rawText);
  document.getElementById('wordsOut').textContent = words.join('\\n');

  const found = findWordsInGrid(grid, words);
  const leftover = solver_leftover(grid, found);
  const solPref = norm(document.getElementById('solution').value);
  document.getElementById('leftover').textContent = leftover + (solPref && leftover!==solPref ? '  (≠ Vorgabe '+solPref+')' : '');

  const host=document.getElementById('gridOut'); host.innerHTML='';
  host.style.gridTemplateColumns=`repeat(${grid[0].length}, 1fr)`;
  host.className='grid';
  for(const row of grid){ for(const ch of row){ const d=document.createElement('div'); d.className='cell'; d.textContent=ch; host.appendChild(d);}}

  const st=document.getElementById('status'); st.className='ok'; st.textContent='Fertig.';
};
</script>
</body>
</html>
