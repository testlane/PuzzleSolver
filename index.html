<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Worträtsel‑Solver (Foto → OCR → Lösung)</title>
<style>
  :root{--bg:#0b1220;--fg:#e5e7eb;--muted:#9aa4b2;--acc:#22d3ee;--ok:#a7f3d0;--warn:#fbbf24;--mono:ui-monospace,Menlo,Consolas,monospace;}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);}
  header{padding:12px 14px 0;}
  h1{margin:0 0 6px;font-size:1.2rem}
  p.hint{margin:4px 0 0;color:var(--muted);font-size:.9rem}
  .wrap{display:grid;gap:10px;padding:12px 14px}
  @media(min-width:980px){.wrap{grid-template-columns: 480px 1fr;}}
  .card{border:1px solid #1f2a44;border-radius:10px;background:#0a1324;padding:12px}
  .card h2{font-size:1rem;margin:0 0 8px;color:var(--acc)}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{appearance:none;border:0;border-radius:999px;padding:10px 14px;font-weight:700;cursor:pointer;background:radial-gradient(100% 100% at 0 0,#0ea5e9 0,#22d3ee 100%);color:#001018}
  button.secondary{background:#1f2937;color:var(--fg)}
  button.warn{background:#2b2b0a;color:#ffeaa7;border:1px solid #44420a}
  input[type="number"],input[type="text"]{width:90px;padding:8px 10px;border-radius:10px;border:1px solid #24314a;background:#0b1220;color:var(--fg)}
  input[type="file"]{color:var(--fg)}
  #status{color:var(--muted);font-size:.9rem;margin-top:8px}
  #status.ok{color:var(--ok)} #status.warn{color:var(--warn)}
  canvas{max-width:100%;height:auto;border-radius:8px;border:1px solid #1f2a44;background:#000}
  .overlayTip{font-size:.85rem;color:var(--muted)}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #2a3a57;background:#0b1a33;color:#a5b4fc;font-size:.75rem}
  pre{white-space:pre-wrap;word-break:break-word;font-family:var(--mono)}
  .grid{display:inline-grid;gap:4px;border:1px dashed #264; padding:6px;border-radius:8px}
  .cell{width:24px;height:24px;display:flex;align-items:center;justify-content:center;border:1px solid #244;background:#0b1220;border-radius:4px;font-family:var(--mono)}
  .found{background:#113e2b;border-color:#1f6f4a}
  .miss{background:#3a1010;border-color:#6f1f1f}
</style>
</head>
<body>
<header>
  <h1>Worträtsel‑Solver</h1>
  <p class="hint">Foto aufnehmen/hochladen → Rechteck für <strong>Gitter</strong> & <strong>Wortliste</strong> markieren → OCR → Lösung. Läuft komplett im Browser. (Tesseract.js via CDN, Sprache <em>deu</em>.)</p>
</header>

<div class="wrap">
  <section class="card">
    <h2>1) Bildquelle</h2>
    <div class="row">
      <input id="file" type="file" accept="image/*" capture="environment">
      <button id="openCam" class="secondary" type="button">Kamera</button>
      <button id="snap" class="secondary" type="button" disabled>Foto aufnehmen</button>
    </div>
    <video id="video" playsinline style="width:100%;display:none;border-radius:8px;border:1px solid #1f2a44"></video>
    <canvas id="canvas" width="1280" height="960"></canvas>
    <div class="overlayTip">Tipp: möglichst frontal fotografieren. Danach ziehst du jeweils mit der Maus / dem Finger einen Rahmen um <strong>Gitter</strong> und um die <strong>Wortliste</strong>.</div>
    <div class="row" style="margin-top:8px">
      <button id="markGrid" type="button">Gitter markieren</button>
      <button id="markWords" class="secondary" type="button">Wortliste markieren</button>
      <button id="clearRects" class="secondary" type="button">Markierungen löschen</button>
    </div>
    <div class="row" style="margin-top:8px">
      <label>Zeilen R <input id="rows" type="number" min="5" max="50" value="13"></label>
      <label>Spalten C <input id="cols" type="number" min="5" max="50" value="13"></label>
    </div>
    <div id="status">Bereit.</div>
  </section>

  <section class="card">
    <h2>2) OCR & Lösung</h2>
    <div class="row">
      <button id="run" type="button">OCR starten & lösen</button>
      <span class="pill" id="progressPill">0%</span>
    </div>
    <div class="row" style="margin-top:8px">
      <label>Lösungswort (optional, falls bekannt) <input id="solution" type="text" placeholder="optional"></label>
    </div>
    <div style="margin-top:10px">
      <div><strong>Gefundene Wörter:</strong></div>
      <pre id="wordsOut"></pre>
    </div>
    <div>
      <div><strong>Gitter (OCR → normalisiert):</strong></div>
      <div id="gridOut"></div>
    </div>
    <div style="margin-top:10px">
      <div><strong>Rest / Lösungswort:</strong> <span id="leftover" style="font-family:var(--mono)"></span></div>
    </div>
  </section>
</div>

<!-- Tesseract.js via CDN -->
<script src="https://unpkg.com/tesseract.js@v5.0.4/dist/tesseract.min.js"></script>
<script>
// ---- Utils ----
function norm(s){
  if(!s) return "";
  s = s.replace(/ä/gi,'ae').replace(/ö/gi,'oe').replace(/ü/gi,'ue').replace(/ß/g,'ss');
  s = s.replace(/[^A-Za-z]/g,'');
  return s.toUpperCase();
}
const DIRS=[[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];
function solver_leftover(gridLines, placedWords){
  const R=gridLines.length, C=gridLines[0].length;
  const grid = gridLines.map(r=>r.split(''));
  const mark = Array.from({length:R},()=>Array(C).fill(false));
  function inb(r,c){return r>=0&&r<R&&c>=0&&c<C}
  function markWord(w){
    const L=w.length;
    for(let r=0;r<R;r++)for(let c=0;c<C;c++){
      for(const [dr,dc] of DIRS){
        let rr=r, cc=c, ok=true;
        for(let k=0;k<L;k++){ if(!inb(rr,cc)||grid[rr][cc]!==w[k]){ok=false;break;} rr+=dr; cc+=dc; }
        if(ok){ rr=r; cc=c; for(let k=0;k<L;k++){ mark[rr][cc]=true; rr+=dr; cc+=dc; } }
      }
    }
  }
  for(const w of placedWords) markWord(w);
  let out=""; for(let r=0;r<R;r++)for(let c=0;c<C;c++) if(!mark[r][c]) out+=grid[r][c];
  return out;
}
function cluster1D(items, count, coordFn){
  // simple k-means 1D with sorted init; stable for grid binning
  const pts = items.map(coordFn).sort((a,b)=>a-b);
  const n = Math.min(count, pts.length);
  if(n===0) return [];
  let centers=[];
  for(let i=0;i<n;i++){ centers.push(pts[Math.floor((i+0.5)*pts.length/n)]); }
  for(let iter=0;iter<20;iter++){
    const buckets=Array.from({length:n},()=>[]);
    for(const p of pts){
      let bi=0,bd=Infinity;
      for(let i=0;i<n;i++){const d=Math.abs(p-centers[i]); if(d<bd){bd=d;bi=i;}}
      buckets[bi].push(p);
    }
    let shift=0;
    for(let i=0;i<n;i++){
      if(buckets[i].length){ const m=buckets[i].reduce((a,b)=>a+b,0)/buckets[i].length; shift+=Math.abs(m-centers[i]); centers[i]=m; }
    }
    if(shift<0.1) break;
  }
  centers.sort((a,b)=>a-b);
  return centers;
}

// ---- Camera / Canvas ----
const fileInput=document.getElementById('file');
const openCamBtn=document.getElementById('openCam');
const snapBtn=document.getElementById('snap');
const video=document.getElementById('video');
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
let stream=null;

openCamBtn.onclick = async()=>{
  try{
    stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
    video.srcObject = stream; await video.play();
    video.style.display='block'; snapBtn.disabled=false;
    document.getElementById('status').textContent='Kamera aktiv.';
  }catch(e){
    document.getElementById('status').textContent='Kamera konnte nicht geöffnet werden: '+e.message;
  }
};
snapBtn.onclick = ()=>{
  if(!video.videoWidth){return;}
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  document.getElementById('status').textContent='Foto übernommen.';
};
fileInput.onchange = async(ev)=>{
  const f=ev.target.files?.[0]; if(!f) return;
  const img = new Image(); img.onload=()=>{
    const maxW=1600; const scale=Math.min(1, maxW/img.width);
    canvas.width = Math.round(img.width*scale); canvas.height = Math.round(img.height*scale);
    ctx.drawImage(img,0,0,canvas.width,canvas.height);
    document.getElementById('status').textContent='Bild geladen.';
  };
  img.src = URL.createObjectURL(f);
};

// ---- Rectangle marking ----
let mode=null; // 'grid' | 'words'
let rects={grid:null, words:null};
function draw(){
  const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
  ctx.putImageData(imgData,0,0);
  function drawRect(r,color){
    if(!r) return;
    ctx.save(); ctx.strokeStyle=color; ctx.lineWidth=2; ctx.setLineDash([8,6]);
    ctx.strokeRect(r.x, r.y, r.w, r.h); ctx.restore();
  }
  drawRect(rects.grid,'#22d3ee'); drawRect(rects.words,'#a7f3d0');
}
document.getElementById('markGrid').onclick=()=>{ mode='grid'; document.getElementById('status').textContent='Ziehe ein Rechteck für das Gitter.'; };
document.getElementById('markWords').onclick=()=>{ mode='words'; document.getElementById('status').textContent='Ziehe ein Rechteck für die Wortliste.'; };
document.getElementById('clearRects').onclick=()=>{ rects={grid:null,words:null}; draw(); };

let drag=null;
canvas.addEventListener('pointerdown',(e)=>{
  if(!mode) return;
  const rect=canvas.getBoundingClientRect();
  drag={x:e.clientX-rect.left, y:e.clientY-rect.top, w:0, h:0};
});
canvas.addEventListener('pointermove',(e)=>{
  if(!drag) return;
  const rect=canvas.getBoundingClientRect();
  drag.w = (e.clientX-rect.left)-drag.x; drag.h = (e.clientY-rect.top)-drag.y;
  draw(); ctx.save(); ctx.strokeStyle='#ffd166'; ctx.lineWidth=2; ctx.setLineDash([6,4]);
  ctx.strokeRect(drag.x,drag.y,drag.w,drag.h); ctx.restore();
});
canvas.addEventListener('pointerup',()=>{
  if(!drag) return;
  const r={x:Math.min(drag.x,drag.x+drag.w), y:Math.min(drag.y,drag.y+drag.h)};
  r.w=Math.abs(drag.w); r.h=Math.abs(drag.h);
  rects[mode]=r; drag=null; draw();
  document.getElementById('status').textContent = (mode==='grid'?'Gitter':'Wortliste')+' markiert.';
  mode=null;
});

// ---- OCR + parsing ----
const progressPill=document.getElementById('progressPill');
async function ocrRegion(r){
  const off=document.createElement('canvas'); off.width=r.w; off.height=r.h;
  const octx=off.getContext('2d');
  octx.drawImage(canvas, r.x, r.y, r.w, r.h, 0, 0, r.w, r.h);
  // slight contrast boost
  const id=octx.getImageData(0,0,r.w,r.h);
  const d=id.data;
  for(let i=0;i<d.length;i+=4){
    const g=(d[i]*0.299+d[i+1]*0.587+d[i+2]*0.114);
    const v=g>180?255:(g<70?0:g);
    d[i]=d[i+1]=d[i+2]=v;
  }
  octx.putImageData(id,0,0);
  const worker = await Tesseract.createWorker('deu', 1, {
    logger: m => {
      if(m.status==='recognizing text' && m.progress!=null){
        progressPill.textContent = Math.round(m.progress*100)+'%';
      }
    },
    langPath: 'https://tessdata.projectnaptha.com/4.0.0'
  });
  const res = await worker.recognize(off);
  await worker.terminate();
  return res;
}

function buildGridFromWords(items, R, C){
  // items: {text, bbox: {x0,y0,x1,y1}} for single letters
  const letters = items.filter(it => /^[A-ZÄÖÜß]$/.test(it.text));
  if(letters.length < R*C*0.6) { return null; }
  // cluster by y to rows, by x to columns
  const rowCenters = cluster1D(letters, R, it=> (it.bbox.y0+it.bbox.y1)/2 );
  const colCenters = cluster1D(letters, C, it=> (it.bbox.x0+it.bbox.x1)/2 );
  const grid = Array.from({length:R},()=>Array(C).fill(''));
  for(const it of letters){
    const yc=(it.bbox.y0+it.bbox.y1)/2, xc=(it.bbox.x0+it.bbox.x1)/2;
    let ri=0,rd=Infinity; for(let i=0;i<rowCenters.length;i++){const d=Math.abs(yc-rowCenters[i]); if(d<rd){rd=d;ri=i;}}
    let ci=0,cd=Infinity; for(let j=0;j<colCenters.length;j++){const d=Math.abs(xc-colCenters[j]); if(d<cd){cd=d;ci=j;}}
    const ch = norm(it.text);
    if(ch) grid[ri][ci]=ch[0];
  }
  // Fill any missing with '?' to visualize
  for(let i=0;i<R;i++)for(let j=0;j<C;j++){ if(!grid[i][j]) grid[i][j]='?'; }
  return grid.map(r=>r.join(''));
}

function parseWordlist(text){
  return Array.from(new Set(text.split(/[\r\n]+/).map(s=>norm(s)).filter(Boolean)));
}

function renderGrid(gridLines, hitsSet){
  const host=document.getElementById('gridOut');
  host.innerHTML='';
  host.style.gridTemplateColumns=`repeat(${gridLines[0].length}, 1fr)`;
  host.className='grid';
  for(const row of gridLines){
    for(const ch of row){
      const d=document.createElement('div'); d.className='cell'; d.textContent=ch;
      if(hitsSet && hitsSet.has(d.textContent)) d.classList.add('found');
      host.appendChild(d);
    }
  }
}

function findWordsInGrid(gridLines, words){
  const R=gridLines.length, C=gridLines[0].length;
  const grid = gridLines.map(r=>r.split(''));
  function inb(r,c){return r>=0&&r<R&&c>=0&&c<C}
  function exists(w){
    const L=w.length;
    for(let r=0;r<R;r++)for(let c=0;c<C;c++){
      for(const [dr,dc] of DIRS){
        let rr=r, cc=c, ok=true;
        for(let k=0;k<L;k++){ if(!inb(rr,cc)||grid[rr][cc]!==w[k]){ok=false;break;} rr+=dr; cc+=dc; }
        if(ok) return true;
      }
    }
    return false;
  }
  const found=[]; for(const w of words){ if(w && exists(w)) found.push(w); }
  return found;
}

document.getElementById('run').onclick = async()=>{
  const R=+document.getElementById('rows').value;
  const C=+document.getElementById('cols').value;
  if(!rects.grid || !rects.words){ document.getElementById('status').textContent='Bitte beide Rechtecke markieren (Gitter + Wortliste).'; return; }
  document.getElementById('status').textContent='OCR läuft … (Gitter)';
  progressPill.textContent='0%';
  const gridRes=await ocrRegion(rects.grid);
  document.getElementById('status').textContent='OCR läuft … (Wortliste)';
  progressPill.textContent='0%';
  const wordsRes=await ocrRegion(rects.words);

  // Extract letters with boxes
  const letterItems = gridRes.data.words.flatMap(w=> w.symbols.map(s=>({
    text: s.text,
    bbox: s.bbox || {x0:w.bbox.x0,y0:w.bbox.y0,x1:w.bbox.x1,y1:w.bbox.y1}
  })));
  let grid = buildGridFromWords(letterItems, R, C);
  if(!grid){ document.getElementById('status').className='warn'; document.getElementById('status').textContent='Zu wenige Buchstaben erkannt. Versuche es mit besserem Foto / engerem Rahmen.'; return; }

  const rawText = wordsRes.data.text || '';
  const words = parseWordlist(rawText);
  document.getElementById('wordsOut').textContent = words.join('\\n');

  const found = findWordsInGrid(grid, words);
  const leftover = solver_leftover(grid, found);
  const solPref = norm(document.getElementById('solution').value);
  document.getElementById('leftover').textContent = leftover + (solPref && leftover!==solPref ? '  (≠ Vorgabe '+solPref+')' : '');
  renderGrid(grid);
  document.getElementById('status').className='ok';
  document.getElementById('status').textContent='Fertig.';
};
</script>
</body>
</html>
