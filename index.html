<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Worträtsel Solver (DEU, Warp, OpenCV.js)</title>
<style>
body { font-family: sans-serif; background: #0b1220; color: #e5e7eb; margin: 0; padding: 0; }
header { padding: 12px; }
button { margin: 5px; padding: 10px; border-radius: 5px; cursor: pointer; }
canvas, video { max-width: 100%; }
.progress { height:10px;background:#0f1b33;border:1px solid #1f2a44;border-radius:999px;overflow:hidden;margin-top:5px; }
.bar { height:100%;width:0%;background:linear-gradient(90deg,#22d3ee,#38bdf8);transition:width .1s; }
</style>
</head>
<body>
<header>
<h1>Worträtsel Solver (DEU, Warp, OpenCV.js)</h1>
<input id="file" type="file" accept="image/*">
<button id="openCam">Kamera</button>
<button id="snap" disabled>Foto aufnehmen</button>
<button id="closeCam" disabled>Kamera schließen</button>
<div class="progress"><div id="bar" class="bar"></div></div>
<div id="progline"></div>
</header>
<video id="video" playsinline></video>
<canvas id="canvas"></canvas>
<button id="run" disabled>OCR starten & lösen</button>
<pre id="out"></pre>
<script src="https://unpkg.com/tesseract.js@v5.0.4/dist/tesseract.min.js"></script>
<script async src="https://cdn.jsdelivr.net/npm/opencv.js"></script>
<script>
const fileInput=document.getElementById('file');
const openCamBtn=document.getElementById('openCam');
const snapBtn=document.getElementById('snap');
const closeCamBtn=document.getElementById('closeCam');
const video=document.getElementById('video');
const canvas=document.getElementById('canvas');
const ctx=canvas.getContext('2d');
const runBtn=document.getElementById('run');
const out=document.getElementById('out');
const bar=document.getElementById('bar');
const progline=document.getElementById('progline');
let stream=null;
let worker=null;

fileInput.onchange=e=>{
  const f=e.target.files[0];
  if(!f)return;
  const img=new Image();
  img.onload=()=>{
    canvas.width=img.width;canvas.height=img.height;
    ctx.drawImage(img,0,0);
    runBtn.disabled=false;
  };
  img.src=URL.createObjectURL(f);
};
openCamBtn.onclick=async()=>{
  stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
  video.srcObject=stream; video.style.display='block';
  await video.play();
  snapBtn.disabled=false; closeCamBtn.disabled=false;
};
snapBtn.onclick=()=>{
  canvas.width=video.videoWidth; canvas.height=video.videoHeight;
  ctx.drawImage(video,0,0);
};
closeCamBtn.onclick=()=>{
  if(stream){stream.getTracks().forEach(t=>t.stop());}
  video.pause(); video.srcObject=null;
};

async function initWorker(){
  worker=Tesseract.createWorker('deu',1,{
    logger:m=>{
      if(m.status==='recognizing text'){ bar.style.width=Math.round(m.progress*100)+'%'; }
      if(m.status==='loading language' || m.status==='initializing tesseract'){ progline.textContent=m.status+' '+Math.round(m.progress*100)+'%'; }
    }
  });
  await worker.setParameters({
    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  });
}

function getMinAreaRectPoints(points){
  let mat=new cv.Mat(points.length,1,cv.CV_32FC2);
  for(let i=0;i<points.length;i++){ mat.data32F[i*2]=points[i].x; mat.data32F[i*2+1]=points[i].y; }
  let rotatedRect=cv.minAreaRect(mat);
  let vertices=cv.RotatedRect.points(rotatedRect);
  mat.delete();
  return vertices.map(v=>({x:v.x,y:v.y}));
}

function warpImage(srcCanvas, quad, outW, outH){
  let src=cv.imread(srcCanvas);
  let dst=new cv.Mat();
  let srcTri=cv.matFromArray(4,1,cv.CV_32FC2,[quad[0].x,quad[0].y,quad[1].x,quad[1].y,quad[2].x,quad[2].y,quad[3].x,quad[3].y]);
  let dstTri=cv.matFromArray(4,1,cv.CV_32FC2,[0,0,outW,0,outW,outH,0,outH]);
  let M=cv.getPerspectiveTransform(srcTri,dstTri);
  cv.warpPerspective(src,dst,M,new cv.Size(outW,outH));
  src.delete(); srcTri.delete(); dstTri.delete(); M.delete();
  cv.imshow(srcCanvas,dst);
  dst.delete();
}

runBtn.onclick=async()=>{
  out.textContent='Starte OCR...';
  if(!worker){ await initWorker(); }

  // 1) Vor-OCR pass to find bounding boxes
  const {data:{symbols}}=await worker.recognize(canvas,{ tessedit_pageseg_mode:6 });
  const pts=symbols.map(s=>({x:(s.bbox.x0+s.bbox.x1)/2,y:(s.bbox.y0+s.bbox.y1)/2}));
  if(pts.length<4){ out.textContent='Zu wenige Punkte erkannt.'; return; }

  // 2) Min area rect with OpenCV.js
  const quad=getMinAreaRectPoints(pts);

  // 3) Warp to grid size
  let R=13,C=13; // TODO: dynamisch
  let cellW=50,cellH=50;
  warpImage(canvas,quad,C*cellW,R*cellH);

  // 4) Cell-by-cell OCR
  let resultGrid=[];
  for(let r=0;r<R;r++){
    let row='';
    for(let c=0;c<C;c++){
      let x=c*cellW+cellW*0.05;
      let y=r*cellH+cellH*0.05;
      let w=cellW*0.9;
      let h=cellH*0.9;
      let cell=ctx.getImageData(x,y,w,h);
      let cellCanvas=document.createElement('canvas');
      cellCanvas.width=w; cellCanvas.height=h;
      cellCanvas.getContext('2d').putImageData(cell,0,0);
      const {data:{text}}=await worker.recognize(cellCanvas,{ tessedit_pageseg_mode:10 });
      row+=text.trim().charAt(0) || '?';
    }
    resultGrid.push(row);
  }
  out.textContent=resultGrid.map(r=>r.split('').join(' ')).join('\n');
};
</script>
</body>
</html>
